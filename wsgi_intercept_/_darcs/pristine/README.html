<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.7: http://docutils.sourceforge.net/" />
<title>wsgi_intercept: in-process testing of WSGI applications</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="wsgi-intercept-in-process-testing-of-wsgi-applications">
<h1 class="title">wsgi_intercept: in-process testing of WSGI applications</h1>
<p>Pursuant to Ian Bicking's <a class="reference" href="http://blog.ianbicking.org/best-of-the-web-app-test-frameworks.html">&quot;best Web testing framework&quot;</a> post,
I put together an <a class="reference" href="http://www.advogato.org/person/titus/diary.html?start=119">in-process HTTP-to-WSGI interception mechanism</a> for
my own Web testing system, <a class="reference" href="http://www.idyll.org/~t/www-tools/twill.html">twill</a>.  Because the mechanism is pretty
generic -- it works at the httplib level -- I decided to try adding it into
all of the <em>other</em> Python Web testing frameworks.</p>
<p>This is the result.</p>
<p>Loosely speaking, this library lets you intercept calls to any specific
host/port combination and redirect them into a <a class="reference" href="http://www.python.org/peps/pep-0333.html">WSGI application</a>.  Thus,
you can avoid spawning multiple processes or threads to test your Web app.
The interception works by subclassing httplib.HTTPConnection and installing
it as a handler for 'http' requests; requests that aren't intercepted are
passed on to the standard handler.</p>
<p>Unfortunately each of the Web testing frameworks uses its own specific
mechanism for making HTTP call-outs, so it's impossible to write something
completely generic.  Nonetheless it's not difficult to patch or wrap any of
the existing frameworks to support the interception behavior.</p>
<p>Enjoy!</p>
<p>Titus Brown, <em>titus&#64;caltech.edu</em>, Feb 27, 2006.</p>
<div class="section" id="general-info">
<h1><a name="general-info">General Info</a></h1>
<p><tt class="docutils literal"><span class="pre">wsgi_intercept</span></tt> works by replacing <tt class="docutils literal"><span class="pre">httplib.HTTPConnection</span></tt> with
a subclass, <tt class="docutils literal"><span class="pre">wsgi_intercept.WSGI_HTTPConnection</span></tt>.  This class then
redirects specific server/port combinations into a WSGI application
by emulating a socket.</p>
<p>The functions <tt class="docutils literal"><span class="pre">add_wsgi_intercept(host,</span> <span class="pre">port,</span> <span class="pre">app_create_fn,</span> <span class="pre">script_name='')</span></tt>
and <tt class="docutils literal"><span class="pre">remove_wsgi_intercept(host,port)</span></tt> specify which URLs should be
redirect into what applications.  Note especially that <tt class="docutils literal"><span class="pre">app_create_fn</span></tt> is
a <em>function object</em> returning a WSGI application; <tt class="docutils literal"><span class="pre">script_name</span></tt> becomes
<tt class="docutils literal"><span class="pre">SCRIPT_NAME</span></tt> in the WSGI app's environment, if set.</p>
<p>The code in this package should be treated with care &amp; ripped off rather than
imported or re-used! ;).  You can download it at <a class="reference" href="http://darcs.idyll.org/~t/projects/wsgi_intercept-latest.tar.gz">http://darcs.idyll.org/~t/projects/wsgi_intercept-latest.tar.gz</a>, and a darcs repository is available at
<a class="reference" href="http://darcs.idyll.org/~t/projects/wsgi_intercept/">http://darcs.idyll.org/~t/projects/wsgi_intercept/</a>.</p>
<div class="section" id="mocking-your-http-server">
<h2><a name="mocking-your-http-server">Mocking your HTTP Server</a></h2>
<p>Marc Hedlund has gone one further, and written a full-blown mock HTTP
server for wsgi_intercept.  Combined with wsgi_intercept itself, this
lets you entirely replace client calls to a server with a mock setup
that hits neither the network nor server code.  You can see his work
in the file <tt class="docutils literal"><span class="pre">mock_http.py</span></tt>.  Run <tt class="docutils literal"><span class="pre">mock_http.py</span></tt> to see a test.</p>
</div>
</div>
<div class="section" id="packages-intercepted">
<h1><a name="packages-intercepted">Packages Intercepted</a></h1>
<div class="section" id="urllib2">
<h2><a name="urllib2">urllib2</a></h2>
<p><a class="reference" href="http://docs.python.org/lib/module-urllib2.html">urllib2</a> is a standard Python module, and <tt class="docutils literal"><span class="pre">urllib2.urlopen</span></tt> is a pretty
normal way to open URLs.</p>
<p>The following code will install the WSGI intercept stuff as a default
urllib2 handler:</p>
<pre class="literal-block">
import wsgi_urllib2
wsgi_urllib2.install_opener()
</pre>
<p>The only tricky bit in there is that different handler classes need to
be constructed for Python 2.3 and Python 2.4, because the httplib
interface changed between those versions.</p>
</div>
<div class="section" id="webtest">
<h2><a name="webtest">webtest</a></h2>
<p><a class="reference" href="http://www.cherrypy.org/file/trunk/cherrypy/test/webtest.py">webtest</a> is an extension to <tt class="docutils literal"><span class="pre">unittest</span></tt> that has some nice functions for
testing Web sites.</p>
<p>To install the WSGI intercept handler, do</p>
<pre class="literal-block">
class WSGI_Test(webtest.WebCase):
    HTTP_CONN = wsgi_intercept.WSGI_HTTPConnection
    HOST='localhost'
    PORT=80

    def setUp(self):
        wsgi_intercept.add_wsgi_intercept(self.HOST, self.PORT, create_fn)
</pre>
</div>
<div class="section" id="webunit">
<h2><a name="webunit">webunit</a></h2>
<p><a class="reference" href="http://mechanicalcat.net/tech/webunit/">webunit</a> is another unittest-like framework that contains nice functions
for Web testing.  (<a class="reference" href="http://funkload.nuxeo.org/">funkload</a> uses webunit, too.)</p>
<p>webunit needed to be patched to support different scheme handlers.
The patched package is in webunit/wsgi_webunit/, and the only
file that was changed was webunittest.py; the original is in
webunittest-orig.py.</p>
<p>To install the WSGI intercept handler, do</p>
<pre class="literal-block">
from httplib import HTTP

class WSGI_HTTP(HTTP):
    _connection_class = WSGI_HTTPConnection

class WSGI_WebTestCase(WebTestCase):
    scheme_handlers = dict(http=WSGI_HTTP)

    def setUp(self):
        wsgi_intercept.add_wsgi_intercept('127.0.0.1', 80, create_fn)
</pre>
</div>
<div class="section" id="mechanoid">
<h2><a name="mechanoid">mechanoid</a></h2>
<p><a class="reference" href="http://www.python.org/pypi/mechanoid/">mechanoid</a> is a fork of <a class="reference" href="http://wwwsearch.sf.net/">mechanize</a>.</p>
<p>mechanoid is pretty easy; just use</p>
<pre class="literal-block">
wsgi_intercept.add_wsgi_intercept('localhost', 80, create_fn)

from wsgi_browser import Browser
b = Browser()
</pre>
</div>
<div class="section" id="mechanize">
<h2><a name="mechanize">mechanize</a></h2>
<p><a class="reference" href="http://wwwsearch.sf.net/">mechanize</a> is John J. Lee's port of Perl's WWW::Mechanize to Python.
It mimics a browser.  (It's also what's behind <a class="reference" href="http://www.idyll.org/~t/www-tools/twill.html">twill</a>.)</p>
<p>mechanize is just as easy as mechanoid:</p>
<pre class="literal-block">
wsgi_intercept.add_wsgi_intercept('localhost', 80, create_fn)

from wsgi_browser import Browser
b = Browser()
</pre>
</div>
<div class="section" id="zope-testbrowser">
<h2><a name="zope-testbrowser">zope.testbrowser</a></h2>
<p><a class="reference" href="http://www.python.org/pypi/zope.testbrowser">zope.testbrowser</a> is a prettified interface to <a class="reference" href="http://wwwsearch.sf.net/">mechanize</a> that is used
primarily for testing Zope applications.</p>
<p>zope.testbrowser is also pretty easy:</p>
<pre class="literal-block">
wsgi_intercept.add_wsgi_intercept('localhost', 80, create_fn)

from wsgi_testbrowser import WSGI_Browser
b = WSGI_Browser()
</pre>
</div>
</div>
</div>
</body>
</html>
